buildscript {
	repositories {
		jcenter()
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
	}
	dependencies {
		classpath "commons-io:commons-io:2.6"
		classpath 'net.fabricmc:tiny-remapper:0.3.1.72'
		classpath 'de.undercouch:gradle-download-task:4.0.4'
		classpath "net.fabricmc:stitch:${project.stitch_version}"
		//classpath "cuchaz:enigma-cli:${project.enigma_version}"
		classpath fileTree(dir: 'libs', include: 'recaf-2.17.5.jar')
    	classpath fileTree(dir: 'libs', include: 'BytecodeInjector.jar')
	}
}

plugins {
    // Apply the java-library plugin to add support for Java Library
    id 'de.undercouch.download' version '4.0.4'
    id 'base'
    id 'java-library'
}

def minecraft_version = "1.16.5"
def yarn_version = "${minecraft_version}+build.${project.yarn_build}"
def minecraft_patch_name = "${minecraft_version}-conduit_${project.conduit_patch}"
def minecraft_patch_title = "${minecraft_version}-Conduit_${project.conduit_patch}"

repositories {
    // Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
    mavenCentral()
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "Mojang"
		url 'https://libraries.minecraft.net/'
	}
}

dependencies {
    // This dependency is exported to consumers, that is to say found on their compile classpath.
    //api 'org.apache.commons:commons-math3:3.6.1'
    //implementation 'com.google.code.findbugs:jsr305:3.0.2'

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
    //implementation "net.fabricmc:yarn:${yarn_version}"
    //implementation fileTree(dir: 'libs', include: 'recaf-2.17.5.jar')
    //implementation fileTree(dir: 'libs', include: 'BytecodeInjector.jar')
}

def setupGroup = "setup"
def conduitBuildGroup = "conduit building"
def buildMappingGroup = "mapping build"
def mapJarGroup = "jar mapping"
def cacheFilesMinecraft = file(".gradle/minecraft")
def buildFiles = file("build/conduit/parts")
def finalBuildFiles = file("build/conduit")
def tempDir = file(".gradle/temp")
def localMap = file(".gradle/mappings/tiny.local")
def mappingsDir = file("mappings")
def manifestPath =	".gradle/manifest/${minecraft_version}"
def mergedFile = new File(cacheFilesMinecraft, "${minecraft_version}-merged.jar")
def mergedIntermediary = new File(cacheFilesMinecraft, "${minecraft_version}-merged-intermediary.jar")
def intermediaryJar = new File(cacheFilesMinecraft, "${minecraft_version}-intermediary.jar")
def mergedV2 = new File(cacheFilesMinecraft, "${yarn_version}-mergedv2.tiny")
def namedJar = new File(cacheFilesMinecraft, "${minecraft_version}-named.jar")
def namedUnmergedJar = new File(cacheFilesMinecraft, "${minecraft_version}-named-unmerged.jar")
def namedUnmergedServerJar = new File(cacheFilesMinecraft, "${minecraft_version}-named-unmerged-server.jar")
def versionFile = new File(file(manifestPath), "${minecraft_version}.json")
def versionFile2 = new File(file(manifestPath), "version.json")
def clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
def serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")
def conduitServerJar = new File(cacheFilesMinecraft, "${minecraft_patch_name}-server.jar")
def conduitClientJar = new File(cacheFilesMinecraft, "${minecraft_patch_name}.jar")
def conduitServerInj = new File(cacheFilesMinecraft, "${minecraft_patch_name}-injected-server.jar")
def conduitClientInj = new File(cacheFilesMinecraft, "${minecraft_patch_name}-injected.jar")
def conduitBuildJar = new File(file("build/libs"), "conduit-main.jar")
def conduitObfJar = new File(cacheFilesMinecraft, "${minecraft_patch_name}-obf.jar")
def conduitIntJar = new File(cacheFilesMinecraft, "${minecraft_patch_name}-intermediary.jar")
def conduitFullObf = new File(buildFiles, "${minecraft_patch_name}.jar")
def conduitFullInt = new File(cacheFilesMinecraft, "${minecraft_patch_name}-obf-intermediary.jar")
def conduitServerObf = new File(buildFiles, "${minecraft_patch_name}-server.jar")
def conduitServerInt = new File(cacheFilesMinecraft, "${minecraft_patch_name}-obf-intermediary-server.jar")
def libraries = new File(cacheFilesMinecraft, "libraries")
def libs = new File("build/libs/")

import com.google.common.hash.Hashing
import groovy.io.FileType
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils
import org.apache.commons.io.FileUtils
import java.nio.charset.StandardCharsets
import com.hoodiecoder.recafinjector.InjectorMain

boolean validateChecksum(File file, String checksum) {
	if (file != null) {
		def hash = com.google.common.io.Files.asByteSource(file).hash(Hashing.sha1())
		def builder = new StringBuilder()
		hash.asBytes().each {
			builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
		}
		return builder.toString().equals(checksum)
	}
	return false
}

task downloadMergedV2(type: Download) {
	group = buildMappingGroup
	def url = "https://maven.fabricmc.net/net/fabricmc/yarn/${yarn_version}/yarn-${yarn_version}-mergedv2.jar"
	src com.google.common.net.UrlEscapers.urlFragmentEscaper().escape(url)
	dest new File(cacheFilesMinecraft, "yarn-${yarn_version}-mergedv2.jar")
}

task extractMergedV2(dependsOn: downloadMergedV2, type: Copy) {
	def output = mergedV2
	from({ zipTree(downloadMergedV2.dest) }) {
		include 'mappings/mappings.tiny'
		rename 'mappings.tiny', "../${output.name}"
	}
	into output.parentFile
}

task getClientObf() {
	group = conduitBuildGroup
	description = 'Builds the obfuscated version of conduit for injection.'
	dependsOn 'build'
	dependsOn 'extractMergedV2'
	dependsOn 'injectConduit'
	doLast {
		if (!mergedV2.exists()) {
			logger.warn("No map detected")
			return
		}
		mapJar(conduitFullInt, conduitClientInj, mergedV2, libraries, "named", "intermediary")
		mapJar(conduitFullObf, conduitFullInt, mergedV2, libraries, "intermediary", "official")
	}
}
task getServerObf() {
	group = conduitBuildGroup
	description = 'Builds the obfuscated version of conduit for injection.'
	dependsOn 'build'
	dependsOn 'extractMergedV2'
	dependsOn 'injectConduit'
	doLast {
		if (!mergedV2.exists()) {
			logger.warn("No map detected")
			return
		}
		mapJar(conduitServerInt, conduitServerInj, mergedV2, libraries, "named", "intermediary")
		mapJar(conduitServerObf, conduitServerInt, mergedV2, libraries, "intermediary", "official")
	}
}

task downloadVersionsManifest {
	group = setupGroup
	description = 'Downloads the minecraft versions manifest.'
	//inputs.property "mc_ver", minecraft_version
	inputs.property "currenttime", new Date()
	def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")
	outputs.file(manifestFile)
	doLast {
		logger.lifecycle(":downloading minecraft versions manifest")
		FileUtils.copyURLToFile(new URL("https://launchermeta.mojang.com/mc/game/version_manifest.json"), manifestFile)
	}
}

def getManifestVersion(File manifestFile, String minecraft_version) {
	def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile)) : null
	return manifest != null ? manifest.versions.stream().filter({
		it.id.equals(minecraft_version)
	}).findFirst() : java.util.Optional.empty()
}

task downloadWantedVersionManifest(dependsOn: downloadVersionsManifest) {
	description = 'Downloads the wanted minecraft version manifest.'
	group = setupGroup
	def manifestFile = downloadVersionsManifest.outputs.files.singleFile
	def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

	//have to grab the release time as there's a current timestamp on each element?!
	inputs.property "releaseTime", manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

	outputs.file versionFile

	doLast {
		manifestVersion = getManifestVersion(manifestFile, minecraft_version)
		//nb need to re-read here in case it didn't exist before
		if (manifestVersion.isPresent() || versionFile.exists()) {

			if (manifestVersion.isPresent()) {
				FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionFile)
			}
		} else {
			throw new RuntimeException("No version data for Minecraft version ${minecraft_version}")
		}
	}

}

task downloadMcJars(dependsOn: downloadWantedVersionManifest) {
	description = 'Downloads the minecraft Jarfiles.'
	group = setupGroup
	inputs.files versionFile

	outputs.files(clientJar, serverJar)

	outputs.upToDateWhen {
		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))
		return clientJar.exists() && serverJar.exists() && validateChecksum(clientJar, version.downloads.client.sha1) && validateChecksum(serverJar, version.downloads.server.sha1)
	}

	doLast {
		if (!versionFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
		}

		//reload in case it changed
		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))

		logger.lifecycle(":downloading minecraft jars")

		download {
			src new URL(version.downloads.client.url)
			dest clientJar
			overwrite false
		}

		download {
			src new URL(version.downloads.server.url)
			dest serverJar
			overwrite false
		}
	}
}

task downloadMcLibs(dependsOn: downloadWantedVersionManifest) {
	group = setupGroup
	description = 'Downloads the minecraft libraries.'
	inputs.files versionFile

	outputs.dir(libraries)

	outputs.upToDateWhen { false }

	doLast {
		if (!versionFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
		}

		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile, StandardCharsets.UTF_8))

		logger.lifecycle(":downloading minecraft libraries")

		if (!libraries.exists()) {
			libraries.mkdirs()
		}

		version.libraries.each {
			def downloadUrl = it.downloads.artifact.url
			def str = downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1)
			download {
				src downloadUrl
				dest new File(libraries, str)
				overwrite false
			}
			project.dependencies.add("implementation", files(".gradle/minecraft/libraries/" + str))
		}
	}
}

task mergeJars(dependsOn: downloadMcJars) {
	group = setupGroup
	description = 'Merges client and server jarfiles.'
	inputs.files downloadMcJars.outputs.files.files
	outputs.file(mergedFile)

	doLast {
		logger.lifecycle(":merging jars")
		def merged = mergedFile
		
		if (merged.exists()) {
			return
		}

		def jarMerger = new JarMerger(clientJar, serverJar, merged)
		jarMerger.merge()
		jarMerger.close()
	}
}

void mapJar(File output, File input, File mappings, File libraries, String from, String to) {
	if (output.exists()) {
		output.delete()
	}

	def remapper = TinyRemapper.newRemapper()
			.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
			.renameInvalidLocals(true)
			.rebuildSourceFilenames(true)
			.build()

	try {
		def outputConsumer = new OutputConsumerPath(output.toPath())
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		libraries.eachFileRecurse(FileType.FILES) { file ->
			remapper.readClassPath(file.toPath())
		}
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}

task addMinecraftDependency() {
	dependsOn 'extractMergedV2'
	dependsOn 'downloadMcLibs'
	dependsOn 'mergeJars'
	doLast {
	//mapJar(mergedIntermediary, mergedFile, localMap, libraries, "official", "intermediary")
	mapJar(namedJar, mergedFile, mergedV2, libraries, "official", "named")
	project.dependencies.add("implementation", files(".gradle/minecraft/${minecraft_version}-named.jar"))
	mapJar(namedUnmergedServerJar, serverJar, mergedV2, libraries, "official", "named")
	mapJar(namedUnmergedJar, clientJar, mergedV2, libraries, "official", "named")
	}
}

task createVersionJson(dependsOn: downloadMcJars, type: Copy) {
	outputs.file(versionFile2)
	group = setupGroup
	from (zipTree(clientJar)) {
		include "version.json"
		includeEmptyDirs = false
	}
	into (manifestPath)
}

task updateVersionJson() {
dependsOn 'createVersionJson'
	doLast {
	if (!versionFile.exists() || !versionFile2.exists()) {
		throw new RuntimeException("Version file(s) do not exist")
	}
	def slurper = new JsonSlurper();
	def clientJson = slurper.parseText(FileUtils.readFileToString(versionFile, StandardCharsets.UTF_8))
	def versionJson = slurper.parseText(FileUtils.readFileToString(versionFile2, StandardCharsets.UTF_8))
	clientJson.remove("downloads")
	clientJson.put("id", "${minecraft_patch_name}")
	clientJson.put("mainClass", "conduit.main.Conduit")
	versionJson.put("id", "${minecraft_patch_name}")
	versionJson.put("name", "${minecraft_patch_name}")
	def clientBuilder = new JsonBuilder(clientJson)
	def versionBuilder = new JsonBuilder(versionJson)
	FileUtils.write(file(manifestPath + "/${minecraft_patch_name}.json"), clientBuilder.toString(), StandardCharsets.UTF_8)
	FileUtils.write(file(manifestPath + "/version.json"), versionBuilder.toPrettyString(), StandardCharsets.UTF_8)
	}
}

project.build.dependsOn 'addMinecraftDependency' 

task getConduitClient(type: Jar) {
	outputs.file(conduitClientJar)
	group = conduitBuildGroup
	description = 'Builds the conduit server jarfile.'
	dependsOn 'updateVersionJson'
	dependsOn 'build'
	archiveFileName = "${minecraft_patch_name}.jar"
	destinationDirectory = cacheFilesMinecraft
	doLast {
		if (conduitClientJar.exists()) {
		logger.warn("Conduit client jar already exists")
			return
		}
	}
	from(zipTree(namedUnmergedJar)) {
		exclude "**/version.json"
		exclude "**/META-INF/**"
	}
	from(zipTree(conduitBuildJar))
	include "**/*"
	exclude "**/META-INF/**"
	from(file(manifestPath + "/version.json"))
}

task getConduitServer(type: Jar) {
	outputs.file(conduitServerJar)
	group = conduitBuildGroup
	description = 'Builds the conduit server jarfile.'
	dependsOn 'build'
	dependsOn 'updateVersionJson'
	archiveFileName = "${minecraft_patch_name}-server.jar"
	destinationDirectory = cacheFilesMinecraft
	doLast {
		if (conduitServerJar.exists()) {
		logger.warn("Conduit server jar already exists")
			return
		}
	}
	from(zipTree(namedUnmergedServerJar)) {
		exclude "**/version.json"
	}
	from(zipTree(conduitBuildJar)) {
		exclude "**/META-INF/**"
	}
	include "**/*"
	from(file(manifestPath + "/version.json"))
	manifest {
		attributes(
			'Manifest-Version'	: '1.0',
			'Main-Class'		: 'net.minecraft.server.Main'
		)
	}
}

task injectConduit() {
	dependsOn 'getConduitServer'
	dependsOn 'getConduitClient'
	doLast {
	def injectServer = new com.hoodiecoder.recafinjector.InjectorMain(conduitServerJar)
	def injectClient = new com.hoodiecoder.recafinjector.InjectorMain(conduitClientJar)
	def common = [injectServer, injectClient] as InjectorMain[]
	common.each {main ->
	main.buildBytecode("net/minecraft/resource/ServerResourceManager", "<init>", "(Lnet/minecraft/server/command/CommandManager\$RegistrationEnvironment;I)V").setBytecode(55,
				"NEW conduit/command/ConduitCommandManager",
				"DUP",
				"ALOAD registrationEnvironment",
				"INVOKESPECIAL conduit/command/ConduitCommandManager.<init>(Lnet/minecraft/server/command/CommandManager\$RegistrationEnvironment;)V",
				"CHECKCAST net/minecraft/server/command/CommandManager"
				).addBytecode(60, "PUTFIELD net/minecraft/resource/ServerResourceManager.commandManager Lnet/minecraft/server/command/CommandManager;")
				.assemble()
	}
	injectServer.exportToJar(conduitServerInj)
	injectClient.exportToJar(conduitClientInj)
	}
}

task copyServerTemp(type: Copy) {
	dependsOn 'getServerObf'
	from(conduitServerObf)
	into tempDir
}
task copyClientTemp(type: Copy) {
	dependsOn 'getClientObf'
	from(conduitFullObf)
	from(manifestPath) {
		include "${minecraft_patch_name}.json"
	}
	into file(".gradle/temp/${minecraft_patch_name}")
}

task buildConduitFull(type: Zip) {
	group = conduitBuildGroup
	description = 'Builds the full zip file for conduit client and server.'
	dependsOn 'copyClientTemp'
	dependsOn 'copyServerTemp'
	archiveFileName = "${minecraft_patch_name}-full.zip"
	destinationDirectory = finalBuildFiles
	from(tempDir) {
		include "**/*"
	}
	doLast {
		FileUtils.cleanDirectory(tempDir)
	}
}