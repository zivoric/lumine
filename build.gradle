buildscript {
	repositories {
		jcenter()
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
	}
	dependencies {
		classpath "commons-io:commons-io:2.6"
		classpath 'net.fabricmc:tiny-remapper:0.3.1.72'
		classpath 'de.undercouch:gradle-download-task:4.0.4'
		classpath "net.fabricmc:stitch:${project.stitch_version}"
		//classpath "cuchaz:enigma-cli:${project.enigma_version}"
	}
}

plugins {
    // Apply the java-library plugin to add support for Java Library
    id 'de.undercouch.download' version '4.0.4'
    id 'base'
    id 'java-library'
}

def minecraft_version = "1.16.5"
def minecraft_patch_name = "${minecraft_version}-conduit_${project.conduit_patch}"
def minecraft_patch_Title = "${minecraft_version}-Conduit_${project.conduit_patch}"

repositories {
    // Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
    mavenCentral()
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "Mojang"
		url 'https://libraries.minecraft.net/'
	}
}

configurations {
	/*enigmaRuntime {
		resolutionStrategy {
			cacheDynamicVersionsFor 0, "seconds"
			cacheChangingModulesFor 0, "seconds"
		}
	}*/
}

dependencies {
    // This dependency is exported to consumers, that is to say found on their compile classpath.
    //api 'org.apache.commons:commons-math3:3.6.1'
    //implementation 'com.google.code.findbugs:jsr305:3.0.2'

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
    implementation "net.fabricmc:yarn:${project.yarn_version}"
    /*enigmaRuntime "cuchaz:enigma-swing:${project.enigma_version}"
	enigmaRuntime "net.fabricmc:stitch:${project.stitch_version}"*/
}

def setupGroup = "setup"
def conduitBuildGroup = "conduit building"
def buildMappingGroup = "mapping build"
def mapJarGroup = "jar mapping"
def cacheFilesMinecraft = file(".gradle/minecraft")
def buildFiles = file("build/conduit/parts")
def finalBuildFiles = file("build/conduit")
def tempDir = file(".gradle/temp")
def localMap = file(".gradle/mappings/tiny.local")
def mappingsDir = file("mappings")
def manifestPath =	".gradle/manifest/${minecraft_version}"
def mergedFile = file("${minecraft_version}-merged.jar")
def intermediaryJar = file("${minecraft_version}-intermediary.jar")
def namedJar = file("${minecraft_version}-named.jar")
def versionFile = new File(file(manifestPath), "${minecraft_version}.json")
def versionFile2 = new File(file(manifestPath), "version.json")
def clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
def serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")
def conduitServerJar = new File(buildFiles, "${minecraft_patch_name}-server.jar")
def conduitClientJar = new File(buildFiles, "${minecraft_patch_name}.jar")
def conduitBuildJar = new File(file("build/libs"), "conduit-main.jar")
def conduitObfJar = new File(cacheFilesMinecraft, "${minecraft_patch_name}-obf.jar")
def conduitIntJar = new File(cacheFilesMinecraft, "${minecraft_patch_name}-intermediary.jar")
def libraries = new File(cacheFilesMinecraft, "libraries")

import com.google.common.hash.Hashing
import groovy.io.FileType
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder
/*import net.fabricmc.stitch.commands.CommandMergeTiny
import net.fabricmc.stitch.commands.CommandProposeFieldNames
import net.fabricmc.stitch.commands.CommandReorderTiny
import net.fabricmc.stitch.commands.CommandRewriteIntermediary
import net.fabricmc.stitch.commands.tinyv2.CommandMergeTinyV2
import net.fabricmc.stitch.commands.tinyv2.CommandProposeV2FieldNames
import net.fabricmc.stitch.commands.tinyv2.CommandReorderTinyV2
import net.fabricmc.stitch.merge.JarMerger*/
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils
import org.apache.commons.io.FileUtils
import java.nio.charset.StandardCharsets

boolean validateChecksum(File file, String checksum) {
	if (file != null) {
		def hash = com.google.common.io.Files.asByteSource(file).hash(Hashing.sha1())
		def builder = new StringBuilder()
		hash.asBytes().each {
			builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
		}
		return builder.toString().equals(checksum)
	}
	return false
}

task obfuscateConduit() {
	group = conduitBuildGroup
	description = 'Builds the obfuscated version of conduit for injection.'
	dependsOn 'build'
	doLast {
		if (!localMap.exists()) {
			logger.warn("No map detected")
			return
		}
		mapJar(conduitIntJar, conduitBuildJar, localMap, libraries, "named", "intermediary")
		mapJar(conduitObfJar, conduitIntJar, localMap, libraries, "intermediary", "official")
	}
}

task downloadVersionsManifest {
	group = setupGroup
	description = 'Downloads the minecraft versions manifest.'
	//inputs.property "mc_ver", minecraft_version
	inputs.property "currenttime", new Date()
	def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")
	outputs.file(manifestFile)
	doLast {
		logger.lifecycle(":downloading minecraft versions manifest")
		FileUtils.copyURLToFile(new URL("https://launchermeta.mojang.com/mc/game/version_manifest.json"), manifestFile)
	}
}

def getManifestVersion(File manifestFile, String minecraft_version) {
	def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile)) : null
	return manifest != null ? manifest.versions.stream().filter({
		it.id.equals(minecraft_version)
	}).findFirst() : java.util.Optional.empty()
}

task downloadWantedVersionManifest(dependsOn: downloadVersionsManifest) {
	description = 'Downloads the wanted minecraft version manifest.'
	group = setupGroup
	def manifestFile = downloadVersionsManifest.outputs.files.singleFile
	def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

	//have to grab the release time as there's a current timestamp on each element?!
	inputs.property "releaseTime", manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

	outputs.file versionFile

	doLast {
		manifestVersion = getManifestVersion(manifestFile, minecraft_version)
		//nb need to re-read here in case it didn't exist before
		if (manifestVersion.isPresent() || versionFile.exists()) {

			if (manifestVersion.isPresent()) {
				FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionFile)
			}
		} else {
			throw new RuntimeException("No version data for Minecraft version ${minecraft_version}")
		}
	}

}

task downloadMcJars(dependsOn: downloadWantedVersionManifest) {
	description = 'Downloads the minecraft Jarfiles.'
	group = setupGroup
	inputs.files versionFile

	outputs.files(clientJar, serverJar)

	outputs.upToDateWhen {
		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))
		return clientJar.exists() && serverJar.exists() && validateChecksum(clientJar, version.downloads.client.sha1) && validateChecksum(serverJar, version.downloads.server.sha1)
	}

	doLast {
		if (!versionFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
		}

		//reload in case it changed
		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))

		logger.lifecycle(":downloading minecraft jars")

		download {
			src new URL(version.downloads.client.url)
			dest clientJar
			overwrite false
		}

		download {
			src new URL(version.downloads.server.url)
			dest serverJar
			overwrite false
		}
	}
}

task downloadMcLibs(dependsOn: downloadWantedVersionManifest) {
	group = setupGroup
	description = 'Downloads the minecraft libraries.'
	inputs.files versionFile

	outputs.dir(libraries)

	outputs.upToDateWhen { false }

	doLast {
		if (!versionFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
		}

		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile, StandardCharsets.UTF_8))

		logger.lifecycle(":downloading minecraft libraries")

		if (!libraries.exists()) {
			libraries.mkdirs()
		}

		version.libraries.each {
			def downloadUrl = it.downloads.artifact.url

			download {
				src downloadUrl
				dest new File(libraries, downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1))
				overwrite false
			}
		}
	}
}

void mapJar(File output, File input, File mappings, File libraries, String from, String to) {
	if (output.exists()) {
		output.delete()
	}

	def remapper = TinyRemapper.newRemapper()
			.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
			.renameInvalidLocals(true)
			.rebuildSourceFilenames(true)
			.build()

	try {
		def outputConsumer = new OutputConsumerPath(output.toPath())
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		libraries.eachFileRecurse(FileType.FILES) { file ->
			remapper.readClassPath(file.toPath())
		}
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}

task createVersionJson(dependsOn: downloadMcJars, type: Copy) {
	outputs.file(versionFile2)
	group = setupGroup
	from (zipTree(clientJar)) {
		include "version.json"
		includeEmptyDirs = false
	}
	into (manifestPath)
}

task updateVersionJson() {
dependsOn 'createVersionJson'
	if (!versionFile.exists() || !versionFile2.exists()) {
		throw new RuntimeException("Version file(s) do not exist")
	}
	def slurper = new JsonSlurper();
	def clientJson = slurper.parseText(FileUtils.readFileToString(versionFile, StandardCharsets.UTF_8))
	def versionJson = slurper.parseText(FileUtils.readFileToString(versionFile2, StandardCharsets.UTF_8))
	clientJson.remove("downloads")
	clientJson.put("id", "${minecraft_patch_name}")
	versionJson.put("id", "${minecraft_patch_name}")
	versionJson.put("name", "${minecraft_patch_name}")
	def clientBuilder = new JsonBuilder(clientJson)
	def versionBuilder = new JsonBuilder(versionJson)
	FileUtils.write(file(manifestPath + "/${minecraft_patch_name}.json"), clientBuilder.toString(), StandardCharsets.UTF_8)
	FileUtils.write(file(manifestPath + "/version.json"), versionBuilder.toPrettyString(), StandardCharsets.UTF_8)
}

task getConduitClient(type: Jar) {
	inputs.files(versionFile, versionFile2)
	outputs.file(conduitClientJar)
	group = conduitBuildGroup
	description = 'Builds the conduit server jarfile.'
	dependsOn 'obfuscateConduit'
	dependsOn 'build'
	dependsOn 'downloadMcLibs'
	dependsOn 'downloadMcJars'
	archiveFileName = "${minecraft_patch_name}.jar"
	destinationDirectory = buildFiles
	doLast {
		if (conduitClientJar.exists()) {
		logger.warn("Conduit client jar already exists")
			return
		}
	}
	from(zipTree(clientJar)) {
		exclude "**/version.json"
	}
	from(zipTree(conduitObfJar))
	include "**/*"
	exclude "**/META-INF/**"
	from(file(manifestPath + "/version.json"))
}

task getConduitServer(type: Jar) {
	outputs.file(conduitServerJar)
	group = conduitBuildGroup
	description = 'Builds the conduit server jarfile.'
	dependsOn 'build'
	dependsOn 'obfuscateConduit'
	dependsOn 'downloadMcLibs'
	dependsOn 'downloadMcJars'
	archiveFileName = "${minecraft_patch_name}-server.jar"
	destinationDirectory = buildFiles
	doLast {
		if (conduitServerJar.exists()) {
		logger.warn("Conduit server jar already exists")
			return
		}
	}
	from(zipTree(serverJar)) {
		exclude "**/version.json"
	}
	from(zipTree(conduitObfJar))
	include "**/*"
	exclude "**/META-INF/**"
	from(file(manifestPath + "/version.json"))
}


task copyServerTemp(type: Copy) {
	dependsOn 'getConduitServer'
	from(conduitServerJar)
	into tempDir
}
task copyClientTemp(type: Copy) {
	dependsOn 'getConduitClient'
	from(conduitClientJar)
	from(manifestPath) {
		include "${minecraft_patch_name}.json"
	}
	into file(".gradle/temp/${minecraft_patch_name}")
}

task buildConduit(type: Zip) {
	group = conduitBuildGroup
	description = 'Builds the full zip file for conduit client and server.'
	dependsOn 'copyClientTemp'
	dependsOn 'copyServerTemp'
	archiveFileName = "${minecraft_patch_name}-full.zip"
	destinationDirectory = finalBuildFiles
	from(tempDir) {
		include "**/*"
	}
	doLast {
		FileUtils.cleanDirectory(tempDir)
	}
}

/*
task mergeTiny(dependsOn: ["buildYarnTiny", "invertIntermediary"], type: FileOutput) {
	group = buildMappingGroup
	def yarnTinyInput = buildYarnTiny.v1Output
	def intermediaryTinyInput = invertIntermediary.output

	def unorderedResultMappings = new File(tempDir, "mappings-unordered.tiny")
	output = new File(tempDir, "mappings.tiny")
	outputs.file(output)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":merging yarn and intermediary")
		String[] args = [
				intermediaryTinyInput.getAbsolutePath(),
				yarnTinyInput.getAbsolutePath(),
				unorderedResultMappings.getAbsolutePath(),
				"intermediary",
				"official"
		]

		new CommandMergeTiny().run(args)

		logger.lifecycle(":reordering merged intermediary")
		String[] args2 = [
				unorderedResultMappings.getAbsolutePath(),
				output.getAbsolutePath(),
				"official", "intermediary", "named"
		]

		new CommandReorderTiny().run(args2)
	}
}

task buildYarnTiny(dependsOn: mapIntermediaryJar, type: WithV2FileOutput) {
	group = buildMappingGroup
	inputs.dir mappingsDir
	if (!libs.exists()) {
		libs.mkdirs()
	}

	v1Output = new File(tempDir, "yarn-mappings.tiny")
	v2Output = new File(tempDir, "yarn-mappings-v2.tiny")

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":generating tiny mappings")

		new MapSpecializedMethodsCommand().run(
			intermediaryJar.getAbsolutePath(),
			"enigma",
			mappingsDir.getAbsolutePath(),
			"tinyv2:intermediary:named",
			v2Output.getAbsolutePath()
		)

		new ConvertMappingsCommand().run(
			"tinyv2",
			v2Output.getAbsolutePath(),
			"tiny:intermediary:named",
			v1Output.getAbsolutePath())
	}
}

task invertIntermediaryv2(dependsOn: extractIntermediaryV2, type: FileOutput) {
	group = buildMappingGroup
	def v2Input = new File(cacheFilesMinecraft, "${minecraft_version}-intermediary-v2.tiny")

	output = new File(cacheFilesMinecraft, "${minecraft_version}-intermediary-inverted-v2.tiny")
	outputs.file(output)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":building inverted intermediary v2")

		String[] v2Args = [
				v2Input.getAbsolutePath(),
				output.getAbsolutePath(),
				"intermediary", "official"
		]

		new CommandReorderTinyV2().run(v2Args)
	}
}

task extractIntermediaryV2(dependsOn: downloadIntermediaryV2, type: Copy) {
	def output = new File(cacheFilesMinecraft, "${minecraft_version}-intermediary-v2.tiny")
	from({ zipTree(downloadIntermediaryV2.dest) }) {
		include 'mappings/mappings.tiny'
		rename 'mappings.tiny', "../${output.name}"
	}
	into output.parentFile
}

task downloadIntermediaryV2(type: Download) {
	group = buildMappingGroup
	def url = "https://maven.fabricmc.net/net/fabricmc/intermediary/${minecraft_version}/intermediary-${minecraft_version}-v2.jar"
	src com.google.common.net.UrlEscapers.urlFragmentEscaper().escape(url)
	dest new File(cacheFilesMinecraft, "${minecraft_version}-intermediary-v2.jar")
}

task mapIntermediaryJar(dependsOn: [downloadMcLibs, downloadIntermediary, mergeJars]) {
	group = mapJarGroup
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(intermediaryJar)

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":mapping minecraft to intermediary")
		def tinyInput = downloadIntermediary.dest
		mapJar(intermediaryJar, mergedFile, tinyInput, libraries, "official", "intermediary")
	}
}

task downloadIntermediary(type: Download) {
	group = buildMappingGroup
	def url = "https://github.com/FabricMC/intermediary/raw/master/mappings/${minecraft_version}.tiny"
	src com.google.common.net.UrlEscapers.urlFragmentEscaper().escape(url)
	dest new File(cacheFilesMinecraft, "${minecraft_version}-intermediary.tiny")
}

task mergeJars(dependsOn: downloadMcJars) {
	group = setupGroup
	inputs.files downloadMcJars.outputs.files.files
	outputs.file(mergedFile)

	doLast {
		logger.lifecycle(":merging jars")
		def client = inputs.files.files.find { it.name.endsWith("-client.jar") }
		def server = inputs.files.files.find { it.name.endsWith("-server.jar") }
		def merged = mergedFile

		if (merged.exists()) {
			return
		}

		def jarMerger = new JarMerger(client, server, merged)
		jarMerger.merge()
		jarMerger.close()
	}
}

class FileOutput extends DefaultTask {
	@OutputFile
	File output
}

class WithV2FileOutput extends DefaultTask {
	@OutputFile
	File v1Output
	@OutputFile
	File v2Output
}*/